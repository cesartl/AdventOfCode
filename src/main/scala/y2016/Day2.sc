type Keypad = Seq[Seq[Char]]
type Position = (Int, Int)

def getValue(keypad: Keypad, position: Position): Char = keypad(position._1)(position._2)

sealed trait Instr {
  def move(position: Position, keypad: Keypad): Position

  def check(position: Position, keypad: Keypad): Option[Position] = {
    if (position._1 < 0 || position._1 >= keypad.size) {
      None
    } else if (position._2 < 0 || position._2 >= keypad.size) {
      None
    } else if (getValue(keypad, position).equals(' ')) {
      None
    } else {
      Some(position)
    }
  }
}

case class U() extends Instr {
  override def move(position: (Int, Int), keypad: Keypad) = check((position._1 - 1, position._2), keypad).getOrElse(position)
}

case class D() extends Instr {
  override def move(position: (Int, Int), keypad: Keypad) = check((position._1 + 1, position._2), keypad).getOrElse(position)
}

case class R() extends Instr {
  override def move(position: (Int, Int), keypad: Keypad) = check((position._1, position._2 + 1), keypad).getOrElse(position)
}

case class L() extends Instr {
  override def move(position: (Int, Int), keypad: Keypad) = check((position._1, position._2 - 1), keypad).getOrElse(position)
}

def parseInstr(s: Char) = s match {
  case 'U' => U()
  case 'D' => D()
  case 'L' => L()
  case 'R' => R()
}

def reduce(start: Position, instructions: Seq[Instr], keypad: Keypad): Position =
  instructions.foldLeft(start) {
    (position, i) => i.move(position, keypad)
  }


def findCode(start: Position, keypad: Keypad, instructions: Seq[Seq[Instr]]): Seq[Char] =
  instructions.foldLeft((start, List[Position]())) {
    (state, instructions) => {
      val p = reduce(state._1, instructions, keypad)
      (p, p :: state._2)
    }
  }._2.map(p => getValue(keypad, p))

def parse(s: String): Seq[Seq[Instr]] = s.split("\n").toList.map(_.map(parseInstr).toList)

val keyPad = List(List('1', '2', '3'), List('4', '5', '6'), List('7', '8', '9'))

val test = "ULL\nRRDDD\nLURDL\nUUUUD"
val cesar = "LLRRLLRLDDUURLLRDUUUDULUDLUULDRDDDULLLRDDLLLRRDDRRUDDURDURLRDDULRRRLLULLULLRUULDLDDDUUURRRRURURDUDLLRRLDLLRRDRDLLLDDRRLUDDLDDLRDRDRDDRUDDRUUURLDUDRRLULLLDRDRRDLLRRLDLDRRRRLURLLURLRDLLRUDDRLRDRRURLDULURDLUUDURLDRURDRDLULLLLDUDRLLURRLRURUURDRRRULLRULLDRRDDDULDURDRDDRDUDUDRURRRRUUURRDUUDUDDDLRRUUDDUUDDDUDLDRDLRDUULLRUUDRRRDURLDDDLDLUULUDLLRDUDDDDLDURRRDRLLRUUUUDRLULLUUDRLLRDLURLURUDURULUDULUDURUDDULDLDLRRUUDRDDDRLLRRRRLDRRRD\nDRRRDULLRURUDRLRDLRULRRLRLDLUDLUURUUURURULRLRUDRURRRLLUDRLLDUDULLUUDLLUUUDDRLRUDDDDLDDUUDULDRRRDULUULDULDRUUULRUDDDUDRRLRLUDDURLLDRLUDUDURUUDRLUURRLUUUDUURUDURLUUUDRDRRRDRDRULLUURURDLUULLDUULUUDULLLDURLUDRURULDLDLRDRLRLUURDDRLDDLRRURUDLUDDDLDRLULLDRLLLURULLUURLUDDURRDDLDDDDRDUUULURDLUUULRRLRDLDRDDDRLLRUDULRRRUDRRLDRRUULUDDLLDUDDRLRRDLDDULLLRDURRURLLULURRLUULULRDLULLUUULRRRLRUDLRUUDDRLLLLLLLURLDRRUURLDULDLDDRLLLRDLLLDLRUUDRURDRDLUULDDRLLRRURRDULLULURRDULRUDUDRLUUDDDDUULDDDUUDURLRUDDULDDDDRUULUUDLUDDRDRD\nRRRULLRULDRDLDUDRRDULLRLUUDLULLRUULULURDDDLLLULRURLLURUDLRDLURRRLRLDLLRRURUDLDLRULDDULLLUUDLDULLDRDLRUULDRLURRRRUDDLUDLDDRUDDUULLRLUUDLUDUDRLRUULURUDULDLUUDDRLLUUURRURUDDRURDLDRRDRULRRRRUUUDRDLUUDDDUDRLRLDRRRRUDDRLLRDRLUDRURDULUUURUULLRDUUULRULRULLRULRLUDUDDULURDDLLURRRULDRULDUUDDULDULDRLRUULDRDLDUDRDUDLURLLURRDLLDULLDRULDLLRDULLRURRDULUDLULRRUDDULRLDLDLLLDUDLURURRLUDRRURLDDURULDURRDUDUURURULLLUDDLDURURRURDDDRRDRURRUURRLDDLRRLDDULRLLLDDUDRULUULLULUULDRLURRRLRRRLDRRLULRLRLURDUULDDUDLLLUURRRLDLUDRLLLRRUU\nURLDDDLDRDDDURRRLURRRRLULURLDDUDRDUDDLURURLLRDURDDRLRUURLDLLRDLRUUURLRLDLDRUDDDULLDULLDUULURLDRDUDRRLRRLULRDDULUDULDULLULDLRRLRRLLULRULDLLDULRRLDURRRRDLURDLUDUUUDLURRRRRUDDUDUUDULDLURRDRLRLUDUDUUDULDDURUDDRDRUDLRRUDRULDULRDRLDRUDRLLRUUDDRLURURDRRLRURULLDUUDRDLULRUULUDURRULLRLUUUUUDULRLUUDRDUUULLULUDUDDLLRRLDURRDDDLUDLUUDULUUULDLLLLUUDURRUDUDLULDRRRULLLURDURDDLRRULURUDURULRDRULLRURURRUDUULRULUUDDUDDUURLRLURRRRDLULRRLDRRDURUDURULULLRUURLLDRDRURLLLUUURUUDDDLDURRLLUUUUURLLDUDLRURUUUDLRLRRLRLDURURRURLULDLRDLUDDULLDUDLULLUUUDLRLDUURRR\nRLLDRDURRUDULLURLRLLURUDDLULUULRRRDRLULDDRLUDRDURLUULDUDDDDDUDDDDLDUDRDRRLRLRLURDURRURDLURDURRUUULULLUURDLURDUURRDLDLDDUURDDURLDDDRUURLDURRURULURLRRLUDDUDDDLLULUDUUUDRULLLLULLRDDRDLRDRRDRRDLDLDDUURRRDDULRUUURUDRDDLRLRLRRDLDRDLLDRRDLLUULUDLLUDUUDRDLURRRRULDRDRUDULRLLLLRRULDLDUUUURLDULDDLLDDRLLURLUDULURRRUULURDRUDLRLLLRDDLULLDRURDDLLDUDRUDRLRRLULLDRRDULDLRDDRDUURDRRRLRDLDUDDDLLUDURRUUULLDRLUDLDRRRRDDDLLRRDUURURLRURRDUDUURRDRRUDRLURLUDDDLUDUDRDRURRDDDDRDLRUDRDRLLDULRURULULDRLRLRRLDURRRUL"

findCode((1, 1), keyPad, parse(test)).reverse.mkString("")
findCode((1, 1), keyPad, parse(cesar)).reverse.mkString("")

val keyPad2 = List(
  List(' ', ' ', '1', ' ', ' '),
  List(' ', '2', '3', '4', ' '),
  List('5', '6', '7', '8', '9'),
  List(' ', 'A', 'B', 'C', ' '),
  List(' ', ' ', 'D', ' ', ' ')
)

findCode((2, 0), keyPad2, parse(test)).reverse.mkString("")
findCode((2, 0), keyPad2, parse(cesar)).reverse.mkString("")